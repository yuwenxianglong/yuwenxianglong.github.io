---
title: Pytorch基本操作
author: 赵旭山
tags: Pytorch
---

#### 1. Pytorch基本操作概要

搜索网页学习Pytorch中看到一张结构清晰的思维导图，作者总结得很清晰，引用过来学习学习。如下：

Figure source: [https://zhuanlan.zhihu.com/p/36233589](https://zhuanlan.zhihu.com/p/36233589)

![](/assets/images/pytorchflowchart202002272158.jpg)

#### 2. Tensor属性

```python
x = torch.rand(5, 3)
x.dtype
x.device
x.layout
x.stride()
```

> torch.float32
>
> device(type='cpu')
>
> torch.strided
>
> (3, 1)

dtype就是数据的类型，Pytorch共有八种数据类型：

| Data type                | dtype                         | dtype                |
| ------------------------ | ----------------------------- | -------------------- |
| 32-bit floating point    | torch.float32 or torch.float  | torch.*.FloatTensor  |
| 64-bit floating point    | torch.float64 or torch.double | torch.*.DoubleTensor |
| 16-bit floating point    | torch.float16 or torch.half   | torch.*.HalfTensor   |
| 8-bit integer (unsigned) | torch.uint8                   | torch.*.ByteTensor   |
| 8-bit integer (signed)   | torch.int8                    | torch.*.CharTensor   |
| 16-bit integer (signed)  | torch.int16 or torch.short    | torch.*.ShortTensor  |
| 32-bit integer (signed)  | torch.int32 or torch.int      | torch.*.IntTensor    |
| 64-bit integer (signed)  | torch.int64 or torch.long     | torch.*.LongTensor   |

layout是数据在内存中是怎么存的，分为稀疏张量和致密张量，常用的为致密张量（`torch.strided`）。

笔者**朴素的理解**就是定义的变量在内存中咋存储的，对二维矩阵而言，用了多少列，行则被展平存成一行。`x.t()`等同于矩阵转置，没存，只把两个数据交换了一下输出。

```python
In [7]: x.stride()                                              
Out[7]: (3, 1)

In [8]: x                                                       
Out[8]: 
tensor([[0.6031, 0.0937, 0.3282],
        [0.2758, 0.8520, 0.1412],
        [0.9676, 0.9618, 0.5699],
        [0.1657, 0.2150, 0.9051],
        [0.7828, 0.9131, 0.4832]])

In [9]: x.stride()                                              
Out[9]: (3, 1)

In [10]: x.t()                                                  
Out[10]: 
tensor([[0.6031, 0.2758, 0.9676, 0.1657, 0.7828],
        [0.0937, 0.8520, 0.9618, 0.2150, 0.9131],
        [0.3282, 0.1412, 0.5699, 0.9051, 0.4832]])

In [11]: x.t().stride()                                         
Out[11]: (1, 3)
```

对于三维张量，后两维相乘是第一个数，最后一维是第二个数，最后一个数为1。t()函数只适用于2维及以下的张量，三维及以上不适用。

```python
In [30]: x =torch.rand(3, 8, 5)                                 

In [31]: x.size()                                               
Out[31]: torch.Size([3, 8, 5])

In [32]: x.stride()                                             
Out[32]: (40, 5, 1)

In [33]: xx = torch.rand(6, 3, 7)                               

In [34]: xx.size()                                              
Out[34]: torch.Size([6, 3, 7])

In [35]: xx.stride()                                            
Out[35]: (21, 7, 1)
  
In [36]: xx.t()                                                 
----------------------------------------------------------------
RuntimeError                   Traceback (most recent call last)
<ipython-input-36-0b88b5bf88e4> in <module>
----> 1 xx.t()

RuntimeError: t() expects a tensor with <= 2 dimensions, but self is 3D

```

#### 3. 创建Tensor

##### 3.1 直接创建

###### torch.tensor

```python
In [2]: cell = torch.tensor([[6.50, 0, 0], [0, 6.50, 0], [0, 0, 
   ...: 6.50]])                                                 

In [3]: cell                                                    
Out[3]: 
tensor([[6.5000, 0.0000, 0.0000],
        [0.0000, 6.5000, 0.0000],
        [0.0000, 0.0000, 6.5000]])
```

###### .new()

参考: [https://www.jb51.net/article/180679.htm](https://www.jb51.net/article/180679.htm)

创建一个新的Tensor，该Tensor的**type**和**device**都和原有Tensor一致，且无内容。

```python
In [2]: inputs = torch.rand(5, 3)                               

In [3]: inputs                                                  
Out[3]: 
tensor([[0.7991, 0.8743, 0.1387],
        [0.9594, 0.9258, 0.3077],
        [0.3318, 0.3850, 0.5850],
        [0.9942, 0.3455, 0.2891],
        [0.4658, 0.9288, 0.7334]])

In [4]: new_inputs1 = inputs.new()                               

In [5]: new_inputs1                                              
Out[5]: tensor([])

In [6]: new_inputs2 = torch.Tensor.new(inputs)                  

In [7]: new_inputs2                                             
Out[7]: tensor([])

In [8]: new_inputs3 = inputs.new(inputs.size())                 

In [9]: new_inputs3                                            
Out[9]: 
tensor([[0.0000e+00, 1.4013e-45, 0.0000e+00],
        [0.0000e+00, 0.0000e+00, 0.0000e+00],
        [0.0000e+00, 0.0000e+00, 0.0000e+00],
        [1.1704e-41, 0.0000e+00, 2.2369e+08],
        [0.0000e+00, 0.0000e+00, 0.0000e+00]])

In [10]: inputs.dtype, new_inputs1.dtype, new_inputs2.dtype, new_inputs3.dtype                                          
Out[10]: (torch.float32, torch.float32, torch.float32, torch.float32)

In [11]: inputs.device, new_inputs.device, new_inputs2.device, new_inputs3.device                                      
Out[11]: 
(device(type='cpu'), device(type='cpu'), device(type='cpu'), device(type='cpu'))
```



#### References

* [pytorch入坑一: Tensor及其基本操作](https://zhuanlan.zhihu.com/p/36233589)

* [Pytorch中.new()的作用详解](https://www.jb51.net/article/180679.htm)

